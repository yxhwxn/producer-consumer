# Step01 개선 방향
- Step01에서는 간이로 별도의 동기화 처리 없이, Producer와 Consumer를 구현했음

- 그 과정에서 Consumer가 큐가 비어있어도 소비할 수 있는 기회를 사용해버리기 때문에, 큐에 처리할 메시지가 남아있는 채로 프로그램이 종료되버림

- 개선 방향
  - Producer가 데이터를 생산하고, 큐에 적재하면
  - 그때 Consumer가 큐에서 데이터를 꺼내서 소비하도록

  - Consumer는 큐가 비어있으면 새로운 데이터가 적재될 때까지 대기(wait)
  - Producer는 큐가 가득 차있으면 빈 공간이 생길때까지 대기(wait)

> Java의 Thread API를 활용해서 개선

## 발생한 문제와 및 고려할 점
구현 과정에서 발생한 문제는 다음과 같음

소비자는 큐가 비어있는지 확인하지 않고, 데이터를 소비하려고 하기 때문에 데이터를 소비하지 못한 채 소비 가능한 횟수를 모두 소모해버림

생산자 입장에서는 데이터를 생산하여 큐에 적재했지만,
소비자가 데이터를 소비하지 못했기 때문에 데이터는 큐에 남은 채로 처리되지 않음

## 구현 과정에서 고려할 점
   따라서 이 패턴을 구현하는 과정에서 고려할 점은 다음과 같음

2-1. 동기화 문제
- 생산자와 소비자 모두 동시에 큐에 접근하여 데이터를 업데이트하려고 할 수 있는데, 이 과정에서 데이터 손실이나 불일치가 발생할 수 있음

- 소비자의 데이터 소비 속도가 생산자의 생산 속도보다 더 빠를 수도 있음

- 따라서 소비자는 큐에 적재된 데이터가 없을 경우 새로운 데이터가 적재될 때까지 대기해야 함

2-2. 버퍼 오버플로(Buffer overflow)

- 일반적으로 프로세스에 할당된 메모리 용량의 한계 때문에,
데이터를 적재할 수 있는 큐의 사이즈는 제한된 고정 사이즈를 가짐

- 이 상황에서 생산자는 데이터를 지속적으로 큐에 적재하는 처리를 수행하는데, 소비자의 데이터 소비 속도가 생산자의 생산 속도보다 느릴 수 있음

- 그에 따라 소비자의 데이터 소비 속도가 생산자의 생산 속도를 따라가지 못할 경우, 큐가 가득 차버리는 버퍼 오버플로 문제가 발생하게 됨

- 따라서 생산자는 큐에 여유 공간이 있을 때만 데이터를 적재해야 하며, 그렇지 않으면 여유 공간이 생길 때까지 대기해야 함
